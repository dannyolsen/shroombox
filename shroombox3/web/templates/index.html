<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>Shroombox Control Panel</title>

    <!-- Load Alpine.js and Tailwind directly -->
    <script src="https://unpkg.com/alpinejs@3.12.0/dist/cdn.min.js" defer></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="/static/js/main.js"></script>

    <script>
        // Detect Safari for special handling
        const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
        console.log("Safari detected:", isSafari);
        
        // Add a fallback for Alpine.js in case the CDN fails
        document.addEventListener('DOMContentLoaded', function() {
            setTimeout(function() {
                if (typeof Alpine === 'undefined') {
                    console.error('Alpine.js failed to load from CDN, loading fallback');
                    const fallbackScript = document.createElement('script');
                    fallbackScript.src = 'https://cdn.jsdelivr.net/npm/alpinejs@3.12.0/dist/cdn.min.js';
                    fallbackScript.defer = true;
                    document.head.appendChild(fallbackScript);
                }
            }, 1000);
            
            // Add a safety timeout to hide the loading overlay after 10 seconds
            setTimeout(function() {
                const loadingOverlay = document.getElementById('loading-overlay');
                if (loadingOverlay && loadingOverlay.style.display !== 'none') {
                    console.warn('Loading timeout reached, forcing overlay removal');
                    loadingOverlay.style.display = 'none';
                    
                    // For Safari: force complete loading state
                    if (isSafari) {
                        console.log("Forcing page load completion for Safari");
                        // Dispatch a fake load event to help Safari
                        window.dispatchEvent(new Event('load'));
                    }
                }
            }, 10000);
            
            // Special Safari fix to ensure page completes loading
            if (isSafari) {
                setTimeout(function() {
                    console.log("Safari compatibility mode: forcing completion");
                    // Add a special class for Safari
                    document.body.classList.add('safari-browser');
                    // Force loading completion
                    document.dispatchEvent(new Event('readystatechange'));
                    window.dispatchEvent(new Event('load'));
                    
                    // Check if inputs need initialization
                    setTimeout(function() {
                        const inputs = document.querySelectorAll('input[type="number"]');
                        inputs.forEach(input => {
                            if (!input.value && input.id) {
                                console.log("Forcing input initialization:", input.id);
                                // Trigger a change to ensure Alpine catches it
                                input.dispatchEvent(new Event('input'));
                            }
                        });
                    }, 1000);
                }, 2000);
            }
        });
        
        // Register service worker for better caching
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/service-worker.js')
                    .then(registration => {
                        console.log('Service Worker registered with scope:', registration.scope);
                    })
                    .catch(error => {
                        console.error('Service Worker registration failed:', error);
                    });
            });
        }
        
        // Track loading state
        let alpineLoaded = false;
        let tailwindLoaded = false;
        
        document.addEventListener('alpine:init', () => {
            console.log('Alpine.js initialized successfully');
            alpineLoaded = true;
            checkAllResourcesLoaded();
        });

        document.addEventListener('DOMContentLoaded', () => {
            if (typeof Alpine === 'undefined') {
                console.error('Alpine.js failed to load.');
                document.getElementById('loading-error').textContent = 'Failed to load Alpine.js. Please refresh the page.';
                document.getElementById('loading-error').classList.remove('hidden');
            } else {
                console.log('Alpine.js is available');
            }
            
            // Check if Tailwind is loaded
            if (typeof tailwind !== 'undefined') {
                console.log('Tailwind CSS is available');
                tailwindLoaded = true;
            } else {
                console.error('Tailwind CSS failed to load.');
            }
            
            checkAllResourcesLoaded();
        });
        
        function checkAllResourcesLoaded() {
            if (alpineLoaded && tailwindLoaded) {
                console.log('All resources loaded successfully');
                setTimeout(() => {
                    const loadingOverlay = document.getElementById('loading-overlay');
                    if (loadingOverlay) {
                        loadingOverlay.classList.add('opacity-0');
                        setTimeout(() => {
                            loadingOverlay.classList.add('hidden');
                        }, 500);
                    }
                }, 500); // Give a small delay to ensure Alpine has initialized components
            }
        }
    </script>
    <style>
        [x-cloak] { display: none !important; }
        #loading-overlay {
            transition: opacity 0.5s ease-in-out;
        }
        
        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border-left-color: #4f46e5;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Safari-specific adjustments */
        .safari-browser input[type="number"] {
            -webkit-appearance: none;
            margin: 0;
        }
        .safari-browser .focus-visible:focus {
            outline: 2px solid transparent;
            outline-offset: 2px;
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen p-6">
    <!-- Loading Overlay -->
    <div id="loading-overlay" class="fixed inset-0 bg-white bg-opacity-90 z-50 flex flex-col items-center justify-center">
        <div class="spinner mb-4"></div>
        <p class="text-lg font-medium text-gray-800 mb-2">Loading Shroombox Control Panel...</p>
        <p class="text-sm text-gray-600">This may take a few moments</p>
        <p id="loading-error" class="mt-4 text-red-600 hidden"></p>
    </div>

    <!-- Debug Panel -->
    <div id="debug-panel" class="fixed bottom-0 right-0 bg-black bg-opacity-80 text-white p-4 rounded-tl-lg z-[9000] max-w-lg max-h-64 overflow-auto text-xs font-mono">
        <h3 class="text-sm font-bold mb-2">Debug Panel</h3>
        <div id="debug-log"></div>
    </div>

    <div x-data="controlPanel()" x-init="init()" x-cloak class="max-w-6xl mx-auto space-y-6">
        <div class="flex justify-between items-center">
            <h1 class="text-2xl font-bold text-gray-800">Shroombox Control Panel</h1>
            <a href="/logging" class="inline-flex items-center px-3 py-2 border border-transparent text-sm leading-4 font-medium rounded-md text-white bg-blue-600 hover:bg-blue-700">
                Logging Control
            </a>
        </div>

        <!-- Environment Controls -->
        <div class="bg-white rounded-lg shadow-sm p-6">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-xl font-semibold text-gray-800">Environment Controls</h2>
                <div class="flex items-center">
                    <label class="block text-sm font-medium text-gray-700 mr-2">Growth Phase:</label>
                    <select 
                        id="phase-select"
                        x-model="currentPhase" 
                        @change="updatePhase"
                        class="rounded-md border-gray-300 shadow-sm focus:border-green-500 focus:ring-green-500"
                    >
                        <option value="colonisation">Colonisation</option>
                        <option value="growing">Growing</option>
                        <option value="cake">Cake</option>
                    </select>
                </div>
            </div>
            <div class="grid grid-cols-3 gap-6">
                <!-- Temperature Column -->
                <div>
                    <div class="mb-4">
                        <label class="block text-sm font-medium text-gray-700 mb-1">Temperature</label>
                        <div class="text-2xl font-medium" x-text="measurements.temperature + ' °C'"></div>
                    </div>
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-2">Setpoint (°C)</label>
                        <input 
                            id="temperature-setpoint"
                            type="number" 
                            class="block w-24 rounded-md border border-gray-300 shadow-sm focus:border-green-500 focus:ring-green-500 p-2"
                            step="0.1"
                            min="0"
                            max="40"
                            :value="setpoints.temperature"
                            @input="setpoints.temperature = parseFloat($el.value)"
                            @change="updateSetpoint('temperature')"
                        >
                    </div>
                </div>

                <!-- CO2 Column -->
                <div>
                    <div class="mb-4">
                        <label class="block text-sm font-medium text-gray-700 mb-1">CO2</label>
                        <div class="text-2xl font-medium" x-text="measurements.co2 + ' ppm'"></div>
                    </div>
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-2">Setpoint (ppm)</label>
                        <input 
                            id="co2-setpoint"
                            type="number" 
                            class="block w-24 rounded-md border border-gray-300 shadow-sm focus:border-green-500 focus:ring-green-500 p-2"
                            step="10"
                            min="0"
                            max="20000"
                            :value="setpoints.co2"
                            @input="setpoints.co2 = parseInt($el.value)"
                            @change="updateSetpoint('co2')"
                        >
                    </div>
                </div>

                <!-- Humidity Column -->
                <div>
                    <div class="mb-4">
                        <label class="block text-sm font-medium text-gray-700 mb-1">Humidity</label>
                        <div class="text-2xl font-medium" x-text="measurements.humidity + ' %'"></div>
                    </div>
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-2">Setpoint (%)</label>
                        <input 
                            id="humidity-setpoint"
                            type="number" 
                            class="block w-24 rounded-md border border-gray-300 shadow-sm focus:border-green-500 focus:ring-green-500 p-2"
                            step="1"
                            min="0"
                            max="100"
                            :value="setpoints.humidity"
                            @input="setpoints.humidity = parseFloat($el.value)"
                            @change="updateSetpoint('humidity')"
                        >
                    </div>
                </div>
            </div>
        </div>

        <!-- Device Settings -->
        <div class="bg-white rounded-lg shadow-sm p-6">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-xl font-semibold text-gray-800">Device Settings</h2>
                <div class="flex items-center space-x-2">
                    <div x-show="lastDeviceUpdate" class="text-xs text-gray-500 animate-pulse">
                        Last updated: <span x-text="lastDeviceUpdate"></span>
                    </div>
                    <button 
                        @click="rescanDevices"
                        class="inline-flex items-center px-3 py-2 border border-transparent text-sm leading-4 font-medium rounded-md text-white bg-green-600 hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500"
                        :class="{'opacity-50 cursor-not-allowed': isScanning}"
                        :disabled="isScanning"
                    >
                        <!-- Spinner for loading state -->
                        <svg x-show="isScanning" class="animate-spin -ml-1 mr-2 h-4 w-4 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                            <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                            <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                        </svg>
                        <span x-text="isScanning ? 'Scanning...' : 'Scan for Devices'"></span>
                    </button>
                </div>
            </div>
            <div class="grid grid-cols-2 gap-6">
                <!-- Heater Section -->
                <div class="space-y-4">
                    <h3 class="text-lg font-medium text-gray-700">Heater</h3>
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-1">Select Device</label>
                        <select 
                            x-model="selectedHeater"
                            @change="updateDeviceRole('heater')"
                            class="block w-full rounded-md border-gray-300 shadow-sm focus:border-green-500 focus:ring-green-500 mb-2"
                        >
                            <option value="">Select a device...</option>
                            <template x-for="device in availableDevices" :key="device.ip">
                                <option 
                                    :value="device.ip"
                                    x-text="device.name"
                                ></option>
                            </template>
                        </select>
                        <!-- Heater Device Info -->
                        <div x-show="selectedHeater" class="mt-2 text-sm space-y-1 text-gray-600 bg-gray-50 p-3 rounded-md">
                            <template x-for="device in availableDevices" :key="device.ip">
                                <div x-show="device.ip === selectedHeater">
                                    <div><span class="font-medium">IP:</span> <span x-text="device.ip"></span></div>
                                    <div><span class="font-medium">MAC:</span> <span x-text="device.mac"></span></div>
                                    <div><span class="font-medium">Model:</span> <span x-text="device.model"></span></div>
                                    <div><span class="font-medium">Type:</span> <span x-text="device.type"></span></div>
                                    <div class="space-y-1">
                                        <div class="flex items-center">
                                            <span class="text-sm text-gray-600 mr-2">Status:</span>
                                            <span 
                                                :class="systemStatus.heater.state ? 'px-2 py-1 text-xs font-medium rounded-full bg-green-100 text-green-800' : 'px-2 py-1 text-xs font-medium rounded-full bg-gray-100 text-gray-800'"
                                                x-text="systemStatus.heater.text"
                                            ></span>
                                            <button 
                                                @click="toggleDevice('heater')"
                                                class="ml-2 px-2 py-1 text-xs font-medium rounded bg-blue-500 text-white hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-500"
                                                x-text="systemStatus.heater.state ? 'Turn OFF' : 'Turn ON'"
                                            ></button>
                                        </div>
                                    </div>
                                </div>
                            </template>
                        </div>
                    </div>
                </div>

                <!-- Humidifier Section -->
                <div class="space-y-4">
                    <h3 class="text-lg font-medium text-gray-700">Humidifier</h3>
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-1">Select Device</label>
                        <select 
                            x-model="selectedHumidifier"
                            @change="updateDeviceRole('humidifier')"
                            class="block w-full rounded-md border-gray-300 shadow-sm focus:border-green-500 focus:ring-green-500 mb-2"
                        >
                            <option value="">Select a device...</option>
                            <template x-for="device in availableDevices" :key="device.ip">
                                <option 
                                    :value="device.ip"
                                    x-text="device.name"
                                ></option>
                            </template>
                        </select>
                        <!-- Humidifier Device Info -->
                        <div x-show="selectedHumidifier" class="mt-2 text-sm space-y-1 text-gray-600 bg-gray-50 p-3 rounded-md">
                            <template x-for="device in availableDevices" :key="device.ip">
                                <div x-show="device.ip === selectedHumidifier">
                                    <div><span class="font-medium">IP:</span> <span x-text="device.ip"></span></div>
                                    <div><span class="font-medium">MAC:</span> <span x-text="device.mac"></span></div>
                                    <div><span class="font-medium">Model:</span> <span x-text="device.model"></span></div>
                                    <div><span class="font-medium">Type:</span> <span x-text="device.type"></span></div>
                                    <div class="space-y-1">
                                        <div class="flex items-center">
                                            <span class="text-sm text-gray-600 mr-2">Status:</span>
                                            <span 
                                                :class="systemStatus.humidifier.state ? 'px-2 py-1 text-xs font-medium rounded-full bg-green-100 text-green-800' : 'px-2 py-1 text-xs font-medium rounded-full bg-gray-100 text-gray-800'"
                                                x-text="systemStatus.humidifier.text"
                                            ></span>
                                            <button 
                                                @click="toggleDevice('humidifier')"
                                                class="ml-2 px-2 py-1 text-xs font-medium rounded bg-blue-500 text-white hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-500"
                                                x-text="systemStatus.humidifier.state ? 'Turn OFF' : 'Turn ON'"
                                            ></button>
                                        </div>
                                    </div>
                                </div>
                            </template>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- System Status -->
        <div class="bg-white rounded-lg shadow-sm p-6">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-xl font-semibold text-gray-800">System Status</h2>
                <div class="flex items-center">
                    <div 
                        class="inline-flex items-center px-3 py-1 rounded-full text-sm bg-green-100 text-green-800"
                    >
                        <span class="mr-2">●</span>
                        <span>System Active</span>
                    </div>
                </div>
            </div>
            <div class="grid grid-cols-2 md:grid-cols-4 gap-4">
                <div class="p-4 bg-gray-50 rounded-lg">
                    <div class="text-sm text-gray-600">Fan Speed</div>
                    <div class="text-lg font-medium" x-text="systemStatus.fan_speed + '%'"></div>
                </div>
                <div class="p-4 bg-gray-50 rounded-lg">
                    <div class="text-sm text-gray-600">Heater</div>
                    <div 
                        class="text-lg font-medium"
                        :class="{'text-green-600': systemStatus.heater.state, 'text-gray-600': !systemStatus.heater.state}"
                        x-text="systemStatus.heater.text"
                    ></div>
                </div>
                <div class="p-4 bg-gray-50 rounded-lg">
                    <div class="text-sm text-gray-600">Humidifier</div>
                    <div 
                        class="text-lg font-medium"
                        :class="{'text-green-600': systemStatus.humidifier.state, 'text-gray-600': !systemStatus.humidifier.state}"
                        x-text="systemStatus.humidifier.text"
                    ></div>
                </div>
                <div class="p-4 bg-gray-50 rounded-lg">
                    <div class="text-sm text-gray-600">CPU Temp</div>
                    <div class="text-lg font-medium" x-text="(systemStatus.cpu_temp ?? '--') + '°C'"></div>
                </div>
            </div>
        </div>

        <!-- Terminal Output -->
        <div class="bg-white rounded-lg shadow-sm p-6">
            <h2 class="text-xl font-semibold text-gray-800 mb-4">Terminal Output</h2>
            <div 
                id="terminal-output" 
                class="font-mono text-sm bg-black text-green-400 p-4 rounded-lg h-96 overflow-y-auto"
                style="white-space: pre-wrap; line-height: 1.4;"
            >
            </div>
        </div>
    </div>

    <script>
        // Add debug logging function
        function debugLog(message, type = 'info') {
            const debugLog = document.getElementById('debug-log');
            if (!debugLog) return;
            
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = document.createElement('div');
            logEntry.className = type === 'error' ? 'text-red-400' : (type === 'warning' ? 'text-yellow-400' : 'text-green-400');
            logEntry.textContent = `[${timestamp}] ${message}`;
            
            debugLog.appendChild(logEntry);
            
            // Keep only the last 50 entries
            while (debugLog.children.length > 50) {
                debugLog.removeChild(debugLog.firstChild);
            }
            
            // Auto-scroll to bottom
            debugLog.scrollTop = debugLog.scrollHeight;
            
            // Also log to console
            if (type === 'error') {
                console.error(message);
            } else if (type === 'warning') {
                console.warn(message);
            } else {
                console.log(message);
            }
        }

        function controlPanel() {
            return {
                currentPhase: 'colonisation',
                measurements: { temperature: '--', humidity: '--', co2: '--' },
                setpoints: { temperature: 0, humidity: 0, co2: 0 },
                availableDevices: [],
                selectedHeater: '',
                selectedHumidifier: '',
                isScanning: false,
                lastDeviceUpdate: '',
                systemStatus: {
                    fan_speed: 0,
                    heater: { state: false, text: 'OFF' },
                    humidifier: { state: false, text: 'OFF' },
                    cpu_temp: null
                },
                eventSource: null,
                initStatus: {
                    phase: false,
                    setpoints: false,
                    measurements: false,
                    devices: false,
                    terminal: false
                },
                initErrors: [],

                init() {
                    debugLog('Initializing control panel...');
                    
                    // Initialize lastDeviceUpdate
                    const now = new Date();
                    this.lastDeviceUpdate = now.toLocaleTimeString();
                    
                    // Ensure loading overlay is hidden after initialization
                    setTimeout(() => {
                        const loadingOverlay = document.getElementById('loading-overlay');
                        if (loadingOverlay && loadingOverlay.style.display !== 'none') {
                            loadingOverlay.style.display = 'none';
                            debugLog('Automatically hiding loading overlay after init timeout', 'warning');
                        }
                    }, 5000);
                    
                    // Sequential initialization with error handling
                    this.loadCurrentPhase()
                        .then(() => {
                            debugLog('Phase loaded successfully');
                            return this.loadSetpoints();
                        })
                        .then(() => {
                            debugLog('Setpoints loaded successfully');
                            return this.updateMeasurements();
                        })
                        .then(() => {
                            debugLog('Measurements updated successfully');
                            return this.loadAvailableDevices();
                        })
                        .then(() => {
                            debugLog('Devices loaded successfully');
                            return this.initTerminal();
                        })
                        .then(() => {
                            debugLog('Terminal initialized successfully');
                            return this.updateSystemStatus();
                        })
                        .catch(error => {
                            debugLog(`Initialization error: ${error.message || 'Unknown error'}`, 'error');
                            this.initErrors.push(error.message || 'Unknown error during initialization');
                            // Continue with partial functionality
                        })
                        .finally(() => {
                            debugLog(`Initialization complete with status: ${JSON.stringify(this.initStatus)}`);
                            
                            // Set up more frequent updates for system status
                            setInterval(() => {
                                this.updateSystemStatus().catch(err => debugLog(`Error updating system status: ${err.message}`, 'error'));
                            }, 1000); // Poll every second for device status changes
                            
                            // Set up less frequent updates for measurements
                            setInterval(() => {
                                this.updateMeasurements().catch(err => debugLog(`Error updating measurements: ${err.message}`, 'error'));
                            }, 5000);
                        });
                },

                async loadCurrentPhase() {
                    try {
                        debugLog('Loading current phase...');
                        const response = await fetch('/api/settings');
                        if (!response.ok) throw new Error(`HTTP error ${response.status}`);
                        
                        const data = await response.json();
                        this.currentPhase = data.environment.current_phase;
                        this.initStatus.phase = true;
                        debugLog('Current phase loaded:', this.currentPhase);
                    } catch (error) {
                        debugLog('Error loading current phase:', error, 'error');
                        this.initErrors.push('Failed to load growth phase');
                        throw error;
                    }
                },

                async updatePhase() {
                    try {
                        debugLog(`Updating growth phase to: ${this.currentPhase}...`);
                        
                        // Show loading indicator
                        const phaseSelect = document.getElementById('phase-select');
                        if (phaseSelect) phaseSelect.disabled = true;
                        
                        const response = await fetch('/api/settings');
                        if (!response.ok) throw new Error(`HTTP error ${response.status}`);
                        
                        const settings = await response.json();
                        settings.environment.current_phase = this.currentPhase;

                        const saveResponse = await fetch('/api/settings', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(settings)
                        });

                        if (!saveResponse.ok) {
                            throw new Error(`Failed to update phase: HTTP error ${saveResponse.status}`);
                        }

                        await this.loadSetpoints();
                        debugLog(`Updated growth phase to: ${this.currentPhase}`);
                    } catch (error) {
                        debugLog('Error updating phase:', error, 'error');
                        alert(`Failed to update growth phase: ${error.message || 'Unknown error'}`);
                        await this.loadCurrentPhase(); // revert if failed
                    } finally {
                        // Re-enable select
                        const phaseSelect = document.getElementById('phase-select');
                        if (phaseSelect) phaseSelect.disabled = false;
                    }
                },

                async loadSetpoints() {
                    try {
                        debugLog('Loading setpoints...');
                        const response = await fetch('/api/settings');
                        if (!response.ok) throw new Error(`HTTP error ${response.status}`);
                        
                        const data = await response.json();
                        const phaseSettings = data.environment.phases[this.currentPhase];

                        if (!phaseSettings) {
                            throw new Error(`Phase settings not found for ${this.currentPhase}`);
                        }

                        // Log the raw values for debugging
                        debugLog(`Raw phase settings: ${JSON.stringify(phaseSettings)}`);

                        // Ensure we have valid numbers for all setpoints
                        this.setpoints = {
                            temperature: parseFloat(phaseSettings.temp_setpoint) || 23,
                            humidity: parseFloat(phaseSettings.rh_setpoint) || 60,
                            co2: parseInt(phaseSettings.co2_setpoint) || 10000
                        };
                        
                        // Set input values directly - make a direct DOM update
                        setTimeout(() => {
                            try {
                                const tempInput = document.getElementById('temperature-setpoint');
                                const co2Input = document.getElementById('co2-setpoint');
                                const humidityInput = document.getElementById('humidity-setpoint');
                                
                                if (tempInput) tempInput.value = this.setpoints.temperature;
                                if (co2Input) co2Input.value = this.setpoints.co2;
                                if (humidityInput) humidityInput.value = this.setpoints.humidity;
                                
                                debugLog('Input values set directly in DOM');
                            } catch (err) {
                                debugLog(`Error setting input values: ${err.message}`, 'error');
                            }
                        }, 200);
                        
                        this.initStatus.setpoints = true;
                        debugLog(`Loaded setpoints: ${JSON.stringify(this.setpoints)}`);
                    } catch (error) {
                        debugLog(`Error loading setpoints: ${error.message}`, 'error');
                        this.initErrors.push('Failed to load setpoints');
                        throw error;
                    }
                },

                async updateSetpoint(type) {
                    try {
                        debugLog(`Updating ${type} setpoint to ${this.setpoints[type]}...`);
                        
                        // Get the input element by ID
                        let inputId = `${type}-setpoint`;
                        if (type === 'temperature') {
                            inputId = 'temperature-setpoint';
                        }
                        
                        const inputElement = document.getElementById(inputId);
                        const currentValue = this.setpoints[type];
                        
                        if (inputElement) {
                            inputElement.disabled = true;
                            debugLog(`Disabled ${type} input for update`);
                        }
                        
                        // Simplify the feedback - use a single approach
                        const feedbackDiv = document.createElement('div');
                        feedbackDiv.className = 'mt-2 text-xs text-blue-600';
                        feedbackDiv.textContent = 'Saving...';
                        feedbackDiv.id = `${type}-feedback`;
                        
                        // Remove any existing feedback
                        const existingFeedback = document.getElementById(`${type}-feedback`);
                        if (existingFeedback && existingFeedback.parentNode) {
                            existingFeedback.parentNode.removeChild(existingFeedback);
                        }
                        
                        if (inputElement && inputElement.parentNode) {
                            inputElement.parentNode.appendChild(feedbackDiv);
                        }
                        
                        // Fetch current settings
                        const response = await fetch('/api/settings');
                        if (!response.ok) throw new Error(`HTTP error ${response.status}`);
                        
                        const settings = await response.json();
                        
                        // Map frontend field names to backend field names
                        const fieldMapping = {
                            'temperature': 'temp_setpoint',
                            'humidity': 'rh_setpoint',
                            'co2': 'co2_setpoint'
                        };
                        
                        const fieldName = fieldMapping[type];
                        if (!fieldName) {
                            throw new Error(`Unknown setpoint type: ${type}`);
                        }
                        
                        // Ensure correct value type
                        let value = currentValue;
                        if (type === 'co2') {
                            value = parseInt(value);
                        } else {
                            value = parseFloat(value);
                        }
                        
                        // Update settings
                        settings.environment.phases[this.currentPhase][fieldName] = value;
                        
                        // Save updated settings
                        const saveResponse = await fetch('/api/settings', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(settings)
                        });

                        if (!saveResponse.ok) {
                            throw new Error(`Failed to save setpoint: HTTP error ${saveResponse.status}`);
                        }

                        debugLog(`Updated ${type} setpoint to ${value} successfully`);
                        
                        // Update feedback to show success
                        if (feedbackDiv) {
                            feedbackDiv.className = 'mt-2 text-xs text-green-600';
                            feedbackDiv.textContent = 'Saved!';
                            setTimeout(() => {
                                if (feedbackDiv.parentNode) {
                                    feedbackDiv.parentNode.removeChild(feedbackDiv);
                                }
                            }, 2000);
                        }
                        
                        // Make sure the input value is updated in the DOM
                        if (inputElement) {
                            inputElement.value = value;
                        }
                    } catch (error) {
                        debugLog(`Error updating ${type} setpoint: ${error.message}`, 'error');
                        
                        // Show error message
                        const inputId = `${type}-setpoint`;
                        const inputElement = document.getElementById(inputId);
                        
                        const errorDiv = document.getElementById(`${type}-feedback`);
                        if (errorDiv) {
                            errorDiv.className = 'mt-2 text-xs text-red-600';
                            errorDiv.textContent = `Error: ${error.message}`;
                            
                            setTimeout(() => {
                                if (errorDiv.parentNode) {
                                    errorDiv.parentNode.removeChild(errorDiv);
                                }
                            }, 3000);
                        }
                        
                        alert(`Failed to update ${type} setpoint: ${error.message || 'Unknown error'}`);
                    } finally {
                        // Re-enable the input
                        const inputId = `${type}-setpoint`;
                        const inputElement = document.getElementById(inputId);
                        
                        if (inputElement) {
                            inputElement.disabled = false;
                        }
                    }
                },

                async updateMeasurements() {
                    try {
                        debugLog('Updating measurements...');
                        const response = await fetch('/api/measurements/latest');
                        if (!response.ok) throw new Error(`HTTP error ${response.status}`);
                        
                        const data = await response.json();
                        
                        this.measurements = {
                            temperature: data.temperature ?? '--',
                            humidity: data.humidity ?? '--',
                            co2: data.co2 ?? '--'
                        };
                        
                        this.initStatus.measurements = true;
                        debugLog('Measurements updated:', this.measurements);
                    } catch (error) {
                        debugLog('Error updating measurements:', error, 'error');
                        if (!this.initStatus.measurements) {
                            this.initErrors.push('Failed to load initial measurements');
                            throw error;
                        }
                        // Don't throw for subsequent updates after initialization
                    }
                },

                async loadAvailableDevices() {
                    try {
                        debugLog('Loading available devices...');
                        const response = await fetch('/api/settings');
                        if (!response.ok) throw new Error(`HTTP error ${response.status}`);
                        
                        const data = await response.json();
                        
                        if (data.available_devices && Array.isArray(data.available_devices)) {
                            this.availableDevices = data.available_devices;
                            debugLog("Loaded available devices:", this.availableDevices);
                            
                            // Set selected devices based on roles
                            this.availableDevices.forEach(device => {
                                if (device.role === 'heater') {
                                    this.selectedHeater = device.ip;
                                } else if (device.role === 'humidifier') {
                                    this.selectedHumidifier = device.ip;
                                }
                            });
                            
                            // Get the latest device states from system status
                            try {
                                const statusResponse = await fetch('/api/system/status');
                                if (statusResponse.ok) {
                                    const statusData = await statusResponse.json();
                                    
                                    // Update device states to match system status
                                    this.availableDevices.forEach(device => {
                                        if (device.role === 'heater') {
                                            device.state = statusData.heater.state || false;
                                        } else if (device.role === 'humidifier') {
                                            device.state = statusData.humidifier.state || false;
                                        }
                                    });
                                    
                                    debugLog("Updated device states from system status");
                                }
                            } catch (statusError) {
                                debugLog('Error getting system status for device states:', statusError, 'warning');
                                // Continue with the states from settings.json
                            }
                            
                            this.initStatus.devices = true;
                        } else {
                            debugLog("No available_devices found in settings");
                            throw new Error("No available devices found");
                        }
                    } catch (error) {
                        debugLog('Error loading available devices:', error, 'error');
                        this.initErrors.push('Failed to load available devices');
                        throw error;
                    }
                },

                async updateDeviceRole(role) {
                    try {
                        debugLog(`Updating ${role} assignment...`);
                        
                        // Disable the select while updating
                        const selectElement = role === 'heater' ? 
                            document.querySelector('select[x-model="selectedHeater"]') : 
                            document.querySelector('select[x-model="selectedHumidifier"]');
                        
                        if (selectElement) selectElement.disabled = true;
                        
                        const response = await fetch('/api/settings');
                        if (!response.ok) throw new Error(`HTTP error ${response.status}`);
                        
                        const settings = await response.json();
                        
                        // Get the selected IP based on role
                        const selectedIp = role === 'heater' ? this.selectedHeater : this.selectedHumidifier;
                        
                        if (!selectedIp) {
                            debugLog(`No device selected for ${role}`);
                            return;
                        }
                        
                        // Update role for the selected device and remove from other devices
                        settings.available_devices.forEach(device => {
                            if (device.ip === selectedIp) {
                                device.role = role;
                            } else if (device.role === role) {
                                device.role = null; // Remove role from other devices
                            }
                        });
                        
                        // Save updated settings
                        const saveResponse = await fetch('/api/settings', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(settings)
                        });
                        
                        if (!saveResponse.ok) {
                            throw new Error(`Failed to update ${role} assignment: HTTP error ${saveResponse.status}`);
                        }
                        
                        debugLog(`Updated ${role} assignment to device at ${selectedIp}`);
                    } catch (error) {
                        debugLog(`Error updating ${role} assignment:`, error, 'error');
                        alert(`Failed to update ${role} assignment: ${error.message || 'Unknown error'}`);
                    } finally {
                        // Re-enable the select
                        const selectElement = role === 'heater' ? 
                            document.querySelector('select[x-model="selectedHeater"]') : 
                            document.querySelector('select[x-model="selectedHumidifier"]');
                        
                        if (selectElement) selectElement.disabled = false;
                    }
                },

                async rescanDevices() {
                    try {
                        this.isScanning = true;
                        debugLog('Scanning for devices...');
                        
                        const response = await fetch('/api/devices/scan', {
                            method: 'POST'
                        });
                        
                        if (!response.ok) {
                            throw new Error(`Device scan failed: HTTP error ${response.status}`);
                        }
                        
                        // Reload available devices after scan
                        await this.loadAvailableDevices();
                        
                        // Also update system status to get latest device states
                        await this.updateSystemStatus();
                        
                        // Update the last update timestamp
                        const now = new Date();
                        this.lastDeviceUpdate = now.toLocaleTimeString();
                        
                        debugLog("Device scan completed and UI updated");
                    } catch (error) {
                        debugLog('Error during device scan:', error, 'error');
                        alert(`Device scan failed: ${error.message || 'Unknown error'}`);
                    } finally {
                        this.isScanning = false;
                    }
                },

                getDeviceStatusClass(device) {
                    return device.state ? 
                        'px-2 py-1 text-xs font-medium rounded-full bg-green-100 text-green-800' : 
                        'px-2 py-1 text-xs font-medium rounded-full bg-gray-100 text-gray-800';
                },
                
                getDeviceStatusText(device) {
                    return device.state ? 'ON' : 'OFF';
                },

                async updateSystemStatus() {
                    try {
                        const response = await fetch('/api/system/status');
                        if (!response.ok) throw new Error(`HTTP error ${response.status}`);
                        
                        const data = await response.json();
                        
                        // Update system status
                        this.systemStatus = {
                            fan_speed: data.fan_speed || 0,
                            heater: { 
                                state: data.heater.state || false, 
                                text: data.heater.state ? 'ON' : 'OFF' 
                            },
                            humidifier: { 
                                state: data.humidifier.state || false, 
                                text: data.humidifier.state ? 'ON' : 'OFF' 
                            },
                            cpu_temp: data.cpu_temp
                        };
                        
                        // Update timestamp
                        const now = new Date();
                        this.lastDeviceUpdate = now.toLocaleTimeString();
                    } catch (error) {
                        debugLog('Error updating system status:', error, 'error');
                        // Don't show alerts for system status errors to avoid annoying the user
                    }
                },

                async toggleDevice(device) {
                    try {
                        debugLog(`Toggling ${device}...`);
                        
                        // Get current state
                        const currentState = device === 'heater' ? 
                            this.systemStatus.heater.state : 
                            this.systemStatus.humidifier.state;
                        
                        // Toggle state
                        const newState = !currentState;
                        
                        // Call API to update device state
                        const response = await fetch('/api/devices/control', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                device: device,
                                state: newState
                            })
                        });
                        
                        if (!response.ok) {
                            const errorData = await response.json();
                            throw new Error(errorData.error || `HTTP error ${response.status}`);
                        }
                        
                        // Update UI immediately
                        if (device === 'heater') {
                            this.systemStatus.heater.state = newState;
                            this.systemStatus.heater.text = newState ? 'ON' : 'OFF';
                        } else {
                            this.systemStatus.humidifier.state = newState;
                            this.systemStatus.humidifier.text = newState ? 'ON' : 'OFF';
                        }
                        
                        // Update timestamp
                        const now = new Date();
                        this.lastDeviceUpdate = now.toLocaleTimeString();
                        
                        debugLog(`Successfully toggled ${device} to ${newState ? 'ON' : 'OFF'}`);
                        
                        // Refresh system status after a short delay
                        setTimeout(() => {
                            this.updateSystemStatus().catch(err => debugLog(`Error updating system status: ${err.message}`, 'error'));
                        }, 1000);
                    } catch (error) {
                        debugLog(`Error toggling ${device}:`, error, 'error');
                        alert(`Failed to toggle ${device}: ${error.message || 'Unknown error'}`);
                    }
                },

                initTerminal() {
                    debugLog('Initializing terminal...');
                    const terminalOutput = document.getElementById('terminal-output');
                    if (!terminalOutput) {
                        debugLog("Terminal output element not found", 'error');
                        this.initErrors.push('Terminal output element not found');
                        return Promise.reject(new Error("Terminal output element not found"));
                    }
                    
                    return new Promise((resolve, reject) => {
                        // Clear any existing content
                        terminalOutput.innerHTML = "Connecting to log stream...\n";
                        
                        // Close existing EventSource if any
                        if (this.eventSource) {
                            this.eventSource.close();
                        }
                        
                        // Special handling for Safari
                        if (isSafari) {
                            debugLog("Safari detected - using modified log stream approach");
                            // For Safari, we'll use periodic AJAX instead of EventSource
                            // This helps Safari complete the page load properly
                            terminalOutput.innerHTML += "Using Safari compatibility mode for logs\n";
                            this.initStatus.terminal = true;
                            
                            // Setup periodic polling for logs instead of EventSource for Safari
                            this.safariLogInterval = setInterval(async () => {
                                try {
                                    const response = await fetch('/api/logs/latest?count=10');
                                    if (response.ok) {
                                        const logs = await response.json();
                                        if (logs && logs.length) {
                                            logs.forEach(log => {
                                                terminalOutput.innerHTML += log + "\n";
                                            });
                                            terminalOutput.scrollTop = terminalOutput.scrollHeight;
                                        }
                                    }
                                } catch (err) {
                                    console.error("Error fetching logs:", err);
                                }
                            }, 5000);
                            
                            resolve();
                            return;
                        }
                        
                        // Standard approach for non-Safari browsers
                        // Set up EventSource for terminal updates
                        try {
                            this.eventSource = new EventSource('/api/logs/stream');
                            
                            this.eventSource.onopen = () => {
                                debugLog("Log stream connection established");
                                terminalOutput.innerHTML += "Connected to log stream\n";
                                this.initStatus.terminal = true;
                                resolve();
                            };
                            
                            this.eventSource.onmessage = (event) => {
                                // Skip heartbeat messages
                                if (event.data === "♥") return;
                                
                                const logLine = event.data;
                                terminalOutput.innerHTML += logLine + "\n";
                                terminalOutput.scrollTop = terminalOutput.scrollHeight;
                            };
                            
                            this.eventSource.onerror = (error) => {
                                debugLog('EventSource error:', error, 'error');
                                terminalOutput.innerHTML += "Connection to log stream lost. Reconnecting...\n";
                                
                                // Close the current connection
                                this.eventSource.close();
                                this.eventSource = null;
                                
                                // If this is the initial connection, reject the promise
                                if (!this.initStatus.terminal) {
                                    this.initErrors.push('Failed to connect to log stream');
                                    reject(new Error('Failed to connect to log stream'));
                                } else {
                                    // Try to reconnect after a delay if this is a subsequent error
                                    setTimeout(() => this.reconnectTerminal(), 5000);
                                }
                            };
                            
                            // Set a timeout in case the connection hangs
                            setTimeout(() => {
                                if (!this.initStatus.terminal) {
                                    debugLog('Log stream connection timed out, continuing anyway');
                                    this.initStatus.terminal = true;
                                    resolve();
                                }
                            }, 3000);
                        } catch (error) {
                            debugLog('Error setting up EventSource:', error, 'error');
                            terminalOutput.innerHTML += `Error connecting to log stream: ${error.message}\n`;
                            this.initErrors.push('Error setting up log stream');
                            reject(error);
                        }
                    });
                },
                
                reconnectTerminal() {
                    const terminalOutput = document.getElementById('terminal-output');
                    if (!terminalOutput) return;
                    
                    // Don't try to reconnect in Safari mode
                    if (isSafari && this.safariLogInterval) {
                        terminalOutput.innerHTML += "Safari mode: using periodic log refresh instead of streaming\n";
                        return;
                    }
                    
                    terminalOutput.innerHTML += "Attempting to reconnect...\n";
                    
                    try {
                        this.eventSource = new EventSource('/api/logs/stream');
                        
                        this.eventSource.onopen = () => {
                            debugLog("Log stream reconnected");
                            terminalOutput.innerHTML += "Reconnected to log stream\n";
                        };
                        
                        this.eventSource.onmessage = (event) => {
                            if (event.data === "♥") return;
                            const logLine = event.data;
                            terminalOutput.innerHTML += logLine + "\n";
                            terminalOutput.scrollTop = terminalOutput.scrollHeight;
                        };
                        
                        this.eventSource.onerror = () => {
                            debugLog('EventSource reconnection error');
                            this.eventSource.close();
                            this.eventSource = null;
                            setTimeout(() => this.reconnectTerminal(), 5000);
                        };
                    } catch (error) {
                        debugLog('Error reconnecting to log stream:', error, 'error');
                        setTimeout(() => this.reconnectTerminal(), 5000);
                    }
                },
                
                // Add cleanup method to handle Safari interval
                cleanup() {
                    if (this.eventSource) {
                        this.eventSource.close();
                        this.eventSource = null;
                    }
                    
                    if (this.safariLogInterval) {
                        clearInterval(this.safariLogInterval);
                        this.safariLogInterval = null;
                    }
                }
            };
        }

        function loggingControl() {
            return {
                loggerLevels: {
                    'shroombox': 'INFO',
                    'shroombox.sensor': 'INFO',
                    'shroombox.device': 'INFO',
                    'shroombox.web': 'INFO'
                },
                
                init() {
                    this.loadLogLevels();
                },
                
                async loadLogLevels() {
                    try {
                        const response = await fetch('/api/logging/levels');
                        const data = await response.json();
                        this.loggerLevels = data;
                    } catch (error) {
                        debugLog('Error loading log levels:', error, 'error');
                    }
                },
                
                async updateLogLevel(logger) {
                    try {
                        const data = {};
                        data[logger] = this.loggerLevels[logger];
                        
                        const response = await fetch('/api/logging/levels', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(data)
                        });
                        
                        if (!response.ok) {
                            throw new Error('Failed to update log level');
                        }
                        
                        debugLog(`Updated log level for ${logger} to ${this.loggerLevels[logger]}`);
                    } catch (error) {
                        debugLog('Error updating log level:', error, 'error');
                        alert('Failed to update log level');
                    }
                }
            };
        }
    </script>
</body>
</html> 