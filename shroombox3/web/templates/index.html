<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>Shroombox Control Panel</title>

    <!-- Load Alpine.js and Tailwind directly -->
    <script src="https://unpkg.com/alpinejs@3.12.0/dist/cdn.min.js" defer></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="/static/js/main.js"></script>

    <script>
        // Detect Safari for special handling
        const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
        console.log("Safari detected:", isSafari);
        
        // Add a fallback for Alpine.js in case the CDN fails
        document.addEventListener('DOMContentLoaded', function() {
            setTimeout(function() {
                if (typeof Alpine === 'undefined') {
                    console.error('Alpine.js failed to load from CDN, loading fallback');
                    const fallbackScript = document.createElement('script');
                    fallbackScript.src = 'https://cdn.jsdelivr.net/npm/alpinejs@3.12.0/dist/cdn.min.js';
                    fallbackScript.defer = true;
                    document.head.appendChild(fallbackScript);
                }
            }, 1000);
            
            // Add a safety timeout to hide the loading overlay after 10 seconds
            setTimeout(function() {
                const loadingOverlay = document.getElementById('loading-overlay');
                if (loadingOverlay && loadingOverlay.style.display !== 'none') {
                    console.warn('Loading timeout reached, forcing overlay removal');
                    loadingOverlay.style.display = 'none';
                    
                    // For Safari: force complete loading state
                    if (isSafari) {
                        console.log("Forcing page load completion for Safari");
                        // Dispatch a fake load event to help Safari
                        window.dispatchEvent(new Event('load'));
                    }
                }
            }, 10000);
            
            // Special Safari fix to ensure page completes loading
            if (isSafari) {
                setTimeout(function() {
                    console.log("Safari compatibility mode: forcing completion");
                    // Add a special class for Safari
                    document.body.classList.add('safari-browser');
                    // Force loading completion
                    document.dispatchEvent(new Event('readystatechange'));
                    window.dispatchEvent(new Event('load'));
                    
                    // Check if inputs need initialization
                    setTimeout(function() {
                        const inputs = document.querySelectorAll('input[type="number"]');
                        inputs.forEach(input => {
                            if (!input.value && input.id) {
                                console.log("Forcing input initialization:", input.id);
                                // Trigger a change to ensure Alpine catches it
                                input.dispatchEvent(new Event('input'));
                            }
                        });
                    }, 1000);
                }, 2000);
            }
        });
        
        // Register service worker for better caching
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/service-worker.js')
                    .then(registration => {
                        console.log('Service Worker registered with scope:', registration.scope);
                    })
                    .catch(error => {
                        console.error('Service Worker registration failed:', error);
                    });
            });
        }
        
        // Track loading state
        let alpineLoaded = false;
        let tailwindLoaded = false;
        
        document.addEventListener('alpine:init', () => {
            console.log('Alpine.js initialized successfully');
            alpineLoaded = true;
            
            // Register the controlPanel as a global store
            Alpine.store('controlPanel', controlPanel());
            
            checkAllResourcesLoaded();
        });

        document.addEventListener('DOMContentLoaded', () => {
            if (typeof Alpine === 'undefined') {
                console.error('Alpine.js failed to load.');
                document.getElementById('loading-error').textContent = 'Failed to load Alpine.js. Please refresh the page.';
                document.getElementById('loading-error').classList.remove('hidden');
            } else {
                console.log('Alpine.js is available');
            }
            
            // Check if Tailwind is loaded
            if (typeof tailwind !== 'undefined') {
                console.log('Tailwind CSS is available');
                tailwindLoaded = true;
            } else {
                console.error('Tailwind CSS failed to load.');
            }
            
            checkAllResourcesLoaded();
        });
        
        function checkAllResourcesLoaded() {
            if (alpineLoaded && tailwindLoaded) {
                console.log('All resources loaded successfully');
                setTimeout(() => {
                    const loadingOverlay = document.getElementById('loading-overlay');
                    if (loadingOverlay) {
                        loadingOverlay.classList.add('opacity-0');
                        setTimeout(() => {
                            loadingOverlay.classList.add('hidden');
                        }, 500);
                    }
                }, 500); // Give a small delay to ensure Alpine has initialized components
            }
        }

        // Add debug logging function
        function debugLog(message, type = 'info') {
            const debugLog = document.getElementById('debug-log');
            if (!debugLog) return;
            
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = document.createElement('div');
            logEntry.className = type === 'error' ? 'text-red-400' : (type === 'warning' ? 'text-yellow-400' : 'text-green-400');
            logEntry.textContent = `[${timestamp}] ${message}`;
            
            debugLog.appendChild(logEntry);
            
            // Keep only the last 50 entries
            while (debugLog.children.length > 50) {
                debugLog.removeChild(debugLog.firstChild);
            }
            
            // Auto-scroll to bottom
            debugLog.scrollTop = debugLog.scrollHeight;
            
            // Also log to console
            if (type === 'error') {
                console.error(message);
            } else if (type === 'warning') {
                console.warn(message);
            } else {
            }
        }

        // Preload devices before Alpine initializes
        async function preloadDevices() {
            try {
                console.log("Preloading devices...");
                // Don't update device states from physical devices on initial load
                const response = await fetch('/api/settings?update_states=false');
                if (!response.ok) {
                    throw new Error(`HTTP error ${response.status}`);
                }
                const data = await response.json();
                
                if (data.available_devices && Array.isArray(data.available_devices)) {
                    console.log(`Preloaded ${data.available_devices.length} devices`);
                    
                    // Try to get system status for device states
                    try {
                        const statusResponse = await fetch('/api/system/status?update_states=false');
                        if (statusResponse.ok) {
                            const statusData = await statusResponse.json();
                            
                            // Update device states
                            data.available_devices.forEach(device => {
                                if (device.role === 'heater' && statusData.heater) {
                                    device.state = statusData.heater.state || false;
                                } else if (device.role === 'humidifier' && statusData.humidifier) {
                                    device.state = statusData.humidifier.state || false;
                                }
                            });
                            
                            console.log("Updated device states from system status");
                        }
                    } catch (error) {
                        console.warn("Error getting system status:", error);
                    }
                    
                    return data.available_devices;
                } else {
                    console.warn("No available_devices found in settings");
                    return [];
                }
            } catch (error) {
                console.error("Error preloading devices:", error);
                return [];
            }
        }

        // Start preloading devices immediately
        const preloadedDevicesPromise = preloadDevices();

        function controlPanel() {
            return {
                currentPhase: 'colonisation',
                measurements: { temperature: '--', humidity: '--', co2: '--', fan_speed: '--', sensor_status: null },
                setpoints: { temperature: 0, humidity: 0, co2: 0 },
                pidSettings: { kp: 0, ki: 0, kd: 0 },
                availableDevices: [],
                selectedHeater: '',
                selectedHumidifier: '',
                isScanning: false,
                lastDeviceUpdate: '',
                eventSource: null,
                initStatus: {
                    phase: false,
                    setpoints: false,
                    measurements: false,
                    devices: false,
                    terminal: false
                },
                initErrors: [],
                fanControl: {
                    manualMode: false,
                    speed: 50
                },
                isRefreshing: false,

                init() {
                    debugLog('Initializing control panel...');
                    
                    // Initialize lastDeviceUpdate
                    const now = new Date();
                    this.lastDeviceUpdate = now.toLocaleTimeString();
                    
                    // Ensure loading overlay is hidden after initialization
                    setTimeout(() => {
                        const loadingOverlay = document.getElementById('loading-overlay');
                        if (loadingOverlay && loadingOverlay.style.display !== 'none') {
                            loadingOverlay.style.display = 'none';
                            debugLog('Automatically hiding loading overlay after init timeout', 'warning');
                        }
                    }, 5000);
                    
                    // Use preloaded devices first, then continue with other initialization
                    preloadedDevicesPromise.then(devices => {
                        if (devices && devices.length > 0) {
                            this.availableDevices = devices;
                            debugLog(`Loaded ${devices.length} preloaded devices`);
                            
                            // Set selected devices based on roles
                            this.setSelectedDevicesByRole();
                            
                            this.initStatus.devices = true;
                        } else {
                            debugLog('No preloaded devices found, fetching devices...', 'warning');
                            this.fetchDevices();
                        }
                        
                        // Continue with other initialization
                        this.fetchCurrentPhase();
                        this.fetchSetpoints();
                        this.fetchMeasurements();
                        
                        // Start device polling
                        if (typeof startDevicePolling === 'function') {
                            startDevicePolling();
                            debugLog('Started device polling');
                        } else {
                            debugLog('Device polling function not available', 'warning');
                        }
                    });
                },

                async fetchCurrentPhase() {
                    try {
                        debugLog('Loading current phase...');
                        const response = await fetch('/api/settings?update_states=false');
                        if (!response.ok) throw new Error(`HTTP error ${response.status}`);
                        
                        const data = await response.json();
                        this.currentPhase = data.environment.current_phase;
                        this.initStatus.phase = true;
                        debugLog('Current phase loaded:', this.currentPhase);
                    } catch (error) {
                        debugLog('Error loading current phase:', error, 'error');
                        this.initErrors.push('Failed to load growth phase');
                        throw error;
                    }
                },

                async fetchSetpoints() {
                    try {
                        debugLog('Loading setpoints...');
                        const response = await fetch('/api/settings?update_states=false');
                        if (!response.ok) throw new Error(`HTTP error ${response.status}`);
                        
                        const data = await response.json();
                        const phaseSettings = data.environment.phases[this.currentPhase];

                        if (!phaseSettings) {
                            throw new Error(`Phase settings not found for ${this.currentPhase}`);
                        }

                        // Log the raw values for debugging
                        debugLog(`Raw phase settings: ${JSON.stringify(phaseSettings)}`);

                        // Ensure we have valid numbers for all setpoints
                        this.setpoints = {
                            temperature: parseFloat(phaseSettings.temp_setpoint) || 23,
                            humidity: parseFloat(phaseSettings.rh_setpoint) || 60,
                            co2: parseInt(phaseSettings.co2_setpoint) || 10000
                        };
                        
                        // Load PID settings
                        try {
                            const pidSettings = data.co2?.pid || {};
                            this.pidSettings = {
                                kp: parseFloat(pidSettings.Kp || -1.0),
                                ki: parseFloat(pidSettings.Ki || -0.01),
                                kd: parseFloat(pidSettings.Kd || 0.0)
                            };
                            debugLog(`Loaded PID settings: ${JSON.stringify(this.pidSettings)}`);
                        } catch (pidError) {
                            debugLog(`Error loading PID settings: ${pidError.message}`, 'error');
                            this.pidSettings = { kp: -1.0, ki: -0.01, kd: 0.0 };
                        }
                        
                        // Load fan control settings
                        try {
                            const fanSettings = data.fan || {};
                            this.fanControl = {
                                manualMode: !!fanSettings.manual_control,
                                speed: parseFloat(fanSettings.speed || 50)
                            };
                            debugLog(`Loaded fan control settings: ${JSON.stringify(this.fanControl)}`);
                        } catch (fanError) {
                            debugLog(`Error loading fan control settings: ${fanError.message}`, 'error');
                            this.fanControl = { manualMode: false, speed: 50 };
                        }
                        
                        // Set input values directly - make a direct DOM update
                        setTimeout(() => {
                            try {
                                const tempInput = document.getElementById('temperature-setpoint');
                                const co2Input = document.getElementById('co2-setpoint');
                                const humidityInput = document.getElementById('humidity-setpoint');
                                const kpInput = document.getElementById('kp-setting');
                                const kiInput = document.getElementById('ki-setting');
                                const kdInput = document.getElementById('kd-setting');
                                
                                if (tempInput) tempInput.value = this.setpoints.temperature;
                                if (co2Input) co2Input.value = this.setpoints.co2;
                                if (humidityInput) humidityInput.value = this.setpoints.humidity;
                                if (kpInput) kpInput.value = this.pidSettings.kp;
                                if (kiInput) kiInput.value = this.pidSettings.ki;
                                if (kdInput) kdInput.value = this.pidSettings.kd;
                                
                                debugLog('Input values set directly in DOM');
                            } catch (err) {
                                debugLog(`Error setting input values: ${err.message}`, 'error');
                            }
                        }, 200);
                        
                        this.initStatus.setpoints = true;
                        debugLog(`Loaded setpoints: ${JSON.stringify(this.setpoints)}`);
                    } catch (error) {
                        debugLog(`Error loading setpoints: ${error.message}`, 'error');
                        this.initErrors.push('Failed to load setpoints');
                        throw error;
                    }
                },

                async fetchMeasurements() {
                    try {
                        debugLog('Updating measurements...');
                        const response = await fetch('/api/measurements/latest');
                        if (!response.ok) throw new Error(`HTTP error ${response.status}`);
                        
                        const data = await response.json();
                        
                        this.measurements = {
                            temperature: data.temperature ?? '--',
                            humidity: data.humidity ?? '--',
                            co2: data.co2 ?? '--',
                            fan_speed: data.fan_speed ?? '--',
                            source: data.source || 'unknown',
                            timestamp: data.timestamp,
                            sensor_status: data.sensor_status || null
                        };
                        
                        // Add visual indicator for data source
                        if (data.source === 'sensor') {
                            debugLog('Using real-time sensor data');
                        } else if (data.source === 'cache') {
                            debugLog(`Using cached data (${data.cache_age.toFixed(1)}s old)`);
                        } else if (data.source === 'influxdb') {
                            debugLog('Using data from InfluxDB');
                        }
                        
                        this.initStatus.measurements = true;
                        debugLog('Measurements updated:', this.measurements);
                    } catch (error) {
                        debugLog('Error updating measurements:', error, 'error');
                        if (!this.initStatus.measurements) {
                            this.initErrors.push('Failed to load initial measurements');
                            throw error;
                        }
                        // Don't throw for subsequent updates after initialization
                    }
                },

                // Method to update measurements from polling
                updateMeasurementsFromPolling(data) {
                    if (!data) return;
                    
                    debugLog('Updating measurements from polling...');
                    
                    this.measurements = {
                        temperature: data.temperature ?? this.measurements.temperature,
                        humidity: data.humidity ?? this.measurements.humidity,
                        co2: data.co2 ?? this.measurements.co2,
                        fan_speed: data.fan_speed ?? this.measurements.fan_speed,
                        source: data.source || this.measurements.source,
                        timestamp: data.timestamp || new Date().toISOString(),
                        sensor_status: data.sensor_status || this.measurements.sensor_status
                    };
                    
                    // Add visual indicator for data source
                    if (data.source === 'sensor') {
                        debugLog('Using real-time sensor data from polling');
                    } else if (data.source === 'cache') {
                        debugLog(`Using cached data from polling (${data.cache_age?.toFixed(1) || '?'}s old)`);
                    } else if (data.source === 'influxdb') {
                        debugLog('Using data from InfluxDB via polling');
                    }
                },

                async fetchDevices() {
                    try {
                        debugLog('Loading available devices...');
                        const response = await fetch('/api/settings?update_states=false');
                        if (!response.ok) throw new Error(`HTTP error ${response.status}`);
                        
                        const data = await response.json();
                        
                        if (data.available_devices && Array.isArray(data.available_devices)) {
                            this.availableDevices = data.available_devices;
                            debugLog("Loaded available devices:", this.availableDevices);
                            
                            // Set selected devices based on roles
                            this.setSelectedDevicesByRole();
                            
                            // Get the latest device states from system status
                            try {
                                const statusResponse = await fetch('/api/system/status?update_states=false');
                                if (statusResponse.ok) {
                                    const statusData = await statusResponse.json();
                                    
                                    // Update device states to match system status
                                    this.availableDevices.forEach(device => {
                                        if (device.role === 'heater') {
                                            device.state = statusData.heater.state || false;
                                        } else if (device.role === 'humidifier') {
                                            device.state = statusData.humidifier.state || false;
                                        }
                                    });
                                    
                                    debugLog("Updated device states from system status");
                                }
                            } catch (statusError) {
                                debugLog('Error getting system status for device states:', statusError, 'warning');
                                // Continue with the states from settings.json
                            }
                            
                            this.initStatus.devices = true;
                        } else {
                            debugLog("No available_devices found in settings");
                            throw new Error("No available devices found");
                        }
                    } catch (error) {
                        debugLog('Error loading available devices:', error, 'error');
                        this.initErrors.push('Failed to load available devices');
                        throw error;
                    }
                },

                setSelectedDevicesByRole() {
                    this.availableDevices.forEach(device => {
                        if (device.role === 'heater') {
                            this.selectedHeater = device.ip;
                        } else if (device.role === 'humidifier') {
                            this.selectedHumidifier = device.ip;
                        }
                    });
                },

                async updateDeviceRole(role) {
                    try {
                        debugLog(`Updating ${role} assignment...`);
                        
                        // Disable the select while updating
                        const selectElement = role === 'heater' ? 
                            document.querySelector('select[x-model="selectedHeater"]') : 
                            document.querySelector('select[x-model="selectedHumidifier"]');
                        
                        if (selectElement) selectElement.disabled = true;
                        
                        const response = await fetch('/api/settings?update_states=false');
                        if (!response.ok) throw new Error(`HTTP error ${response.status}`);
                        
                        const settings = await response.json();
                        
                        // Get the selected IP based on role
                        const selectedIp = role === 'heater' ? this.selectedHeater : this.selectedHumidifier;
                        
                        if (!selectedIp) {
                            debugLog(`No device selected for ${role}`);
                            return;
                        }
                        
                        // Update role for the selected device and remove from other devices
                        settings.available_devices.forEach(device => {
                            if (device.ip === selectedIp) {
                                device.role = role;
                            } else if (device.role === role) {
                                device.role = null; // Remove role from other devices
                            }
                        });
                        
                        // Save updated settings
                        const saveResponse = await fetch('/api/settings', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(settings)
                        });
                        
                        if (!saveResponse.ok) {
                            throw new Error(`Failed to update ${role} assignment: HTTP error ${saveResponse.status}`);
                        }
                        
                        debugLog(`Updated ${role} assignment to device at ${selectedIp}`);
                    } catch (error) {
                        debugLog(`Error updating ${role} assignment:`, error, 'error');
                        alert(`Failed to update ${role} assignment: ${error.message || 'Unknown error'}`);
                    } finally {
                        // Re-enable the select
                        const selectElement = role === 'heater' ? 
                            document.querySelector('select[x-model="selectedHeater"]') : 
                            document.querySelector('select[x-model="selectedHumidifier"]');
                        
                        if (selectElement) selectElement.disabled = false;
                    }
                },

                async rescanDevices() {
                    try {
                        this.isScanning = true;
                        debugLog('Scanning for devices...');
                        
                        const response = await fetch('/api/devices/scan?force_scan=true', {
                            method: 'POST'
                        });
                        
                        if (!response.ok) {
                            throw new Error(`Device scan failed: HTTP error ${response.status}`);
                        }
                        
                        // Reload available devices after scan
                        await this.fetchDevices();
                        
                        // Also update system status to get latest device states
                        debugLog("Skipping system status update");
                        
                        // Update the last update timestamp
                        const now = new Date();
                        this.lastDeviceUpdate = now.toLocaleTimeString();
                        
                        debugLog("Device scan completed and UI updated");
                    } catch (error) {
                        debugLog('Error during device scan:', error, 'error');
                        alert(`Device scan failed: ${error.message || 'Unknown error'}`);
                    } finally {
                        this.isScanning = false;
                    }
                },

                getDeviceStatusClass(device) {
                    return device.state ? 
                        'px-2 py-1 text-xs font-medium rounded-full bg-green-100 text-green-800' : 
                        'px-2 py-1 text-xs font-medium rounded-full bg-gray-100 text-gray-800';
                },
                
                getDeviceStatusText(device) {
                    return device.state ? 'ON' : 'OFF';
                },

                async toggleDevice(role) {
                    try {
                        debugLog(`Toggling ${role} device...`);
                        
                        // Find the device by role
                        const device = this.availableDevices.find(d => d.role === role);
                        if (!device) {
                            debugLog(`No device found with role: ${role}`, 'error');
                            return;
                        }
                        
                        // Get the current state and toggle it
                        const newState = !device.state;
                        
                        // Call the API to toggle the device
                        const response = await fetch('/api/devices/control/direct', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                ip: device.ip,
                                state: newState
                            })
                        });
                        
                        if (response.ok) {
                            const data = await response.json();
                            debugLog(`Successfully toggled ${role} to ${data.state ? 'ON' : 'OFF'}`);
                            
                            // Update the device state in our local data
                            device.state = data.state;
                            
                            // Update the last update time
                            const now = new Date();
                            this.lastDeviceUpdate = now.toLocaleTimeString();
                        } else {
                            const error = await response.json();
                            debugLog(`Error toggling ${role}: ${error.message || 'Unknown error'}`, 'error');
                        }
                    } catch (error) {
                        debugLog(`Error toggling ${role}: ${error.message}`, 'error');
                    }
                },

                // Add a method to update device states from the polling mechanism
                updateDeviceStates(devices) {
                    if (!devices || !Array.isArray(devices)) return;
                    
                    let changed = false;
                    
                    // Update each device in our local data
                    devices.forEach(updatedDevice => {
                        const existingDevice = this.availableDevices.find(d => d.ip === updatedDevice.ip);
                        if (existingDevice && existingDevice.state !== updatedDevice.state) {
                            existingDevice.state = updatedDevice.state;
                            changed = true;
                        }
                    });
                    
                    // Update the last update time if any device state changed
                    if (changed) {
                        const now = new Date();
                        this.lastDeviceUpdate = now.toLocaleTimeString();
                    }
                },

                // Function to update setpoints
                async updateSetpoint(type) {
                    try {
                        debugLog(`Updating ${type} setpoint...`);
                        
                        // Get the current value from the setpoints object
                        const value = this.setpoints[type];
                        
                        // Validate the value
                        if (value === undefined || value === null || isNaN(value)) {
                            throw new Error(`Invalid ${type} value: ${value}`);
                        }
                        
                        // Get current settings
                        const response = await fetch('/api/settings?update_states=false');
                        if (!response.ok) throw new Error(`HTTP error ${response.status}`);
                        
                        const settings = await response.json();
                        
                        // Create field mapping
                        const fieldMapping = {
                            'temperature': 'temp_setpoint',
                            'humidity': 'rh_setpoint',
                            'co2': 'co2_setpoint'
                        };
                        
                        // Get the correct field name
                        const fieldName = fieldMapping[type];
                        if (!fieldName) {
                            throw new Error(`Unknown setpoint type: ${type}`);
                        }
                        
                        // Update the setpoint in the settings object
                        settings.environment.phases[this.currentPhase][fieldName] = type === 'co2' ? 
                            parseInt(value) : parseFloat(value);
                        
                        // Show feedback
                        const feedbackId = `${type}-feedback`;
                        let feedbackDiv = document.getElementById(feedbackId);
                        
                        if (!feedbackDiv) {
                            feedbackDiv = document.createElement('div');
                            feedbackDiv.id = feedbackId;
                            feedbackDiv.className = 'mt-2 text-xs text-blue-600';
                            
                            // Find the input element and add feedback after it
                            const inputElement = document.getElementById(`${type}-setpoint`);
                            if (inputElement && inputElement.parentNode) {
                                inputElement.parentNode.appendChild(feedbackDiv);
                            }
                        }
                        
                        feedbackDiv.textContent = 'Saving...';
                        
                        // Save updated settings
                        const saveResponse = await fetch('/api/settings', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(settings)
                        });
                        
                        if (!saveResponse.ok) {
                            throw new Error(`Failed to save ${type} setpoint: HTTP error ${saveResponse.status}`);
                        }
                        
                        // Update feedback
                        feedbackDiv.textContent = `${type.charAt(0).toUpperCase() + type.slice(1)} setpoint updated`;
                        feedbackDiv.className = 'mt-2 text-xs text-green-600';
                        
                        // Remove feedback after 3 seconds
                        setTimeout(() => {
                            if (feedbackDiv && feedbackDiv.parentNode) {
                                feedbackDiv.parentNode.removeChild(feedbackDiv);
                            }
                        }, 3000);
                        
                        debugLog(`Successfully updated ${type} setpoint to ${value}`);
                    } catch (error) {
                        debugLog(`Error updating ${type} setpoint: ${error.message}`, 'error');
                        
                        // Show error feedback
                        const feedbackId = `${type}-feedback`;
                        let feedbackDiv = document.getElementById(feedbackId);
                        
                        if (!feedbackDiv) {
                            feedbackDiv = document.createElement('div');
                            feedbackDiv.id = feedbackId;
                            
                            // Find the input element and add feedback after it
                            const inputElement = document.getElementById(`${type}-setpoint`);
                            if (inputElement && inputElement.parentNode) {
                                inputElement.parentNode.appendChild(feedbackDiv);
                            }
                        }
                        
                        feedbackDiv.textContent = `Error: ${error.message}`;
                        feedbackDiv.className = 'mt-2 text-xs text-red-600';
                        
                        // Remove error feedback after 5 seconds
                        setTimeout(() => {
                            if (feedbackDiv && feedbackDiv.parentNode) {
                                feedbackDiv.parentNode.removeChild(feedbackDiv);
                            }
                        }, 5000);
                    }
                },

                // Add a method to update the phase
                async updatePhase() {
                    try {
                        debugLog(`Updating phase to ${this.currentPhase}...`);
                        
                        // Get current settings
                        const response = await fetch('/api/settings?update_states=false');
                        if (!response.ok) throw new Error(`HTTP error ${response.status}`);
                        
                        const settings = await response.json();
                        
                        // Update the current phase
                        settings.environment.current_phase = this.currentPhase;
                        
                        // Save updated settings
                        const saveResponse = await fetch('/api/settings', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(settings)
                        });
                        
                        if (!saveResponse.ok) {
                            throw new Error(`Failed to update phase: HTTP error ${saveResponse.status}`);
                        }
                        
                        // Reload setpoints for the new phase
                        await this.fetchSetpoints();
                        
                        debugLog(`Successfully updated phase to ${this.currentPhase}`);
                    } catch (error) {
                        debugLog(`Error updating phase: ${error.message}`, 'error');
                        alert(`Failed to update phase: ${error.message}`);
                    }
                },

                // Function to update PID settings
                async updatePidSetting(parameter) {
                    try {
                        debugLog(`Updating PID ${parameter} setting...`);
                        
                        // Get the current value from the pidSettings object
                        const value = this.pidSettings[parameter];
                        
                        // Validate the value
                        if (value === undefined || value === null || isNaN(value)) {
                            throw new Error(`Invalid ${parameter} value: ${value}`);
                        }
                        
                        // Get current settings
                        const response = await fetch('/api/settings?update_states=false');
                        if (!response.ok) throw new Error(`HTTP error ${response.status}`);
                        
                        const settings = await response.json();
                        
                        // Ensure the co2.pid structure exists
                        if (!settings.co2) settings.co2 = {};
                        if (!settings.co2.pid) settings.co2.pid = {};
                        
                        // Update the parameter in the settings object
                        if (parameter === 'kp') {
                            settings.co2.pid.Kp = parseFloat(value);
                        } else if (parameter === 'ki') {
                            settings.co2.pid.Ki = parseFloat(value);
                        } else if (parameter === 'kd') {
                            settings.co2.pid.Kd = parseFloat(value);
                        }
                        
                        // Show feedback
                        const feedbackId = `${parameter}-feedback`;
                        let feedbackDiv = document.getElementById(feedbackId);
                        
                        if (!feedbackDiv) {
                            feedbackDiv = document.createElement('div');
                            feedbackDiv.id = feedbackId;
                            feedbackDiv.className = 'mt-2 text-xs text-blue-600';
                            
                            // Find the input element and add feedback after it
                            const inputElement = document.getElementById(`${parameter}-setting`);
                            if (inputElement && inputElement.parentNode) {
                                inputElement.parentNode.appendChild(feedbackDiv);
                            }
                        }
                        
                        feedbackDiv.textContent = 'Saving...';
                        
                        // Save updated settings
                        const saveResponse = await fetch('/api/settings', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(settings)
                        });
                        
                        if (!saveResponse.ok) {
                            throw new Error(`Failed to save PID ${parameter} setting: HTTP error ${saveResponse.status}`);
                        }
                        
                        // Update feedback
                        feedbackDiv.textContent = `PID ${parameter.toUpperCase()} updated`;
                        feedbackDiv.className = 'mt-2 text-xs text-green-600';
                        
                        // Remove feedback after 3 seconds
                        setTimeout(() => {
                            if (feedbackDiv && feedbackDiv.parentNode) {
                                feedbackDiv.parentNode.removeChild(feedbackDiv);
                            }
                        }, 3000);
                        
                        debugLog(`Successfully updated PID ${parameter} to ${value}`);
                    } catch (error) {
                        debugLog(`Error updating PID ${parameter}: ${error.message}`, 'error');
                        
                        // Show error feedback
                        const feedbackId = `${parameter}-feedback`;
                        let feedbackDiv = document.getElementById(feedbackId);
                        
                        if (!feedbackDiv) {
                            feedbackDiv = document.createElement('div');
                            feedbackDiv.id = feedbackId;
                            
                            // Find the input element and add feedback after it
                            const inputElement = document.getElementById(`${parameter}-setting`);
                            if (inputElement && inputElement.parentNode) {
                                inputElement.parentNode.appendChild(feedbackDiv);
                            }
                        }
                        
                        feedbackDiv.textContent = `Error: ${error.message}`;
                        feedbackDiv.className = 'mt-2 text-xs text-red-600';
                        
                        // Remove error feedback after 5 seconds
                        setTimeout(() => {
                            if (feedbackDiv && feedbackDiv.parentNode) {
                                feedbackDiv.parentNode.removeChild(feedbackDiv);
                            }
                        }, 5000);
                    }
                },

                // Cleanup method
                cleanup() {
                    // Terminal-related cleanup removed
                },

                // Refresh data function for the refresh button
                async refreshData() {
                    try {
                        debugLog('Refreshing dashboard data...');
                        
                        // Set refreshing state
                        this.isRefreshing = true;
                        
                        // Refresh measurements, setpoints, and devices in parallel
                        await Promise.all([
                            this.fetchMeasurements(),
                            this.fetchSetpoints(),
                            this.fetchDevices()
                        ]);
                        
                        debugLog('Dashboard data refreshed successfully');
                    } catch (error) {
                        debugLog(`Error refreshing data: ${error.message}`, 'error');
                    } finally {
                        // Reset refreshing state
                        this.isRefreshing = false;
                    }
                },

                toggleManualFanControl() {
                    debugLog(`Toggling manual fan control to: ${this.fanControl.manualMode}`);
                    
                    // If enabling manual mode, set the initial speed to the current fan speed
                    if (this.fanControl.manualMode && this.measurements.fan_speed !== '--') {
                        this.fanControl.speed = parseFloat(this.measurements.fan_speed);
                    }
                    
                    // Update the settings on the server
                    this.updateFanSettings();
                },
                
                async updateFanSettings() {
                    try {
                        debugLog(`Updating fan settings - Manual mode: ${this.fanControl.manualMode}, Speed: ${this.fanControl.speed}%`);
                        
                        // Get current settings
                        const response = await fetch('/api/settings?update_states=false');
                        if (!response.ok) throw new Error(`HTTP error ${response.status}`);
                        
                        const settings = await response.json();
                        
                        // Update fan settings
                        if (!settings.fan) settings.fan = {};
                        settings.fan.manual_control = this.fanControl.manualMode;
                        settings.fan.speed = parseFloat(this.fanControl.speed);
                        
                        // Save updated settings
                        const saveResponse = await fetch('/api/settings', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(settings)
                        });
                        
                        if (!saveResponse.ok) {
                            throw new Error(`Failed to save fan settings: HTTP error ${saveResponse.status}`);
                        }
                        
                        debugLog(`Successfully updated fan settings`);
                    } catch (error) {
                        debugLog(`Error updating fan settings: ${error.message}`, 'error');
                        alert(`Failed to update fan settings: ${error.message}`);
                    }
                },
                
                async updateManualFanSpeed() {
                    if (!this.fanControl.manualMode) return;
                    
                    try {
                        debugLog(`Setting fan speed to ${this.fanControl.speed}%`);
                        
                        // Clear any previous feedback
                        const feedbackDiv = document.querySelector('#fan-speed-feedback');
                        if (feedbackDiv) {
                            feedbackDiv.textContent = '';
                        }
                        
                        // Call the fan control API
                        const response = await fetch('/api/fan/control', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ speed: parseFloat(this.fanControl.speed) })
                        });
                        
                        if (!response.ok) {
                            throw new Error(`Failed to set fan speed: HTTP error ${response.status}`);
                        }
                        
                        const data = await response.json();
                        debugLog(`Fan speed set successfully: ${data.message}`);
                        
                        // Show success message
                        if (feedbackDiv) {
                            feedbackDiv.textContent = data.message;
                            feedbackDiv.className = 'mt-2 text-sm text-green-600';
                            
                            // Hide the message after 3 seconds
                            setTimeout(() => {
                                feedbackDiv.textContent = '';
                            }, 3000);
                        }
                        
                        // Also update the settings
                        this.updateFanSettings();
                    } catch (error) {
                        debugLog(`Error setting fan speed: ${error.message}`, 'error');
                        
                        // Show error message
                        const feedbackDiv = document.querySelector('#fan-speed-feedback');
                        if (feedbackDiv) {
                            feedbackDiv.textContent = `Error: ${error.message}`;
                            feedbackDiv.className = 'mt-2 text-sm text-red-600';
                            
                            // Hide the message after 5 seconds
                            setTimeout(() => {
                                feedbackDiv.textContent = '';
                            }, 5000);
                        }
                    }
                }
            };
        }

        function loggingControl() {
            return {
                loggerLevels: {
                    'shroombox': 'INFO',
                    'shroombox.sensor': 'INFO',
                    'shroombox.device': 'INFO',
                    'shroombox.web': 'INFO'
                },
                
                init() {
                    this.loadLogLevels();
                },
                
                async loadLogLevels() {
                    try {
                        const response = await fetch('/api/logging/levels');
                        const data = await response.json();
                        this.loggerLevels = data;
                    } catch (error) {
                        debugLog('Error loading log levels:', error, 'error');
                    }
                },
                
                async updateLogLevel(logger) {
                    try {
                        const data = {};
                        data[logger] = this.loggerLevels[logger];
                        
                        const response = await fetch('/api/logging/levels', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(data)
                        });
                        
                        if (!response.ok) {
                            throw new Error('Failed to update log level');
                        }
                        
                        debugLog(`Updated log level for ${logger} to ${this.loggerLevels[logger]}`);
                    } catch (error) {
                        debugLog('Error updating log level:', error, 'error');
                        alert('Failed to update log level');
                    }
                }
            };
        }
    </script>
    <style>
        [x-cloak] { display: none !important; }
        #loading-overlay {
            transition: opacity 0.5s ease-in-out;
        }
        
        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border-left-color: #4f46e5;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Toggle Switch Styles */
        .toggle-checkbox:checked {
            right: 0;
            border-color: #3b82f6;
        }
        .toggle-checkbox:checked + .toggle-label {
            background-color: #3b82f6;
        }
        .toggle-checkbox {
            right: 0;
            z-index: 5;
            transition: all 0.3s;
        }
        .toggle-label {
            transition: background-color 0.3s;
        }
        
        /* Safari-specific adjustments */
        .safari-browser input[type="number"] {
            -webkit-appearance: none;
            margin: 0;
        }
        .safari-browser .focus-visible:focus {
            outline: 2px solid transparent;
            outline-offset: 2px;
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen p-6">
    <!-- Loading Overlay -->
    <div id="loading-overlay" class="fixed inset-0 bg-white bg-opacity-90 z-50 flex flex-col items-center justify-center">
        <div class="spinner mb-4"></div>
        <p class="text-lg font-medium text-gray-800 mb-2">Loading Shroombox Control Panel...</p>
        <p class="text-sm text-gray-600">This may take a few moments</p>
        <p id="loading-error" class="mt-4 text-red-600 hidden"></p>
    </div>

    <div x-data="controlPanel()" x-init="init()" x-cloak class="max-w-6xl mx-auto space-y-6">
        <div class="flex justify-between items-center">
            <h1 class="text-2xl font-bold text-gray-800">Shroombox Control Panel</h1>
            <div class="flex space-x-2">
                <a href="/env-settings" class="inline-flex items-center px-3 py-2 border border-transparent text-sm leading-4 font-medium rounded-md text-white bg-green-600 hover:bg-green-700">
                    Environment Settings
                </a>
                <a href="/settings" class="inline-flex items-center px-3 py-2 border border-transparent text-sm leading-4 font-medium rounded-md text-white bg-yellow-600 hover:bg-yellow-700">
                    Advanced Settings
                </a>
                <a href="/logging" class="inline-flex items-center px-3 py-2 border border-transparent text-sm leading-4 font-medium rounded-md text-white bg-blue-600 hover:bg-blue-700">
                    Logging Control
                </a>
            </div>
        </div>

        <!-- Dashboard Header -->
        <div class="bg-white shadow rounded-lg p-4 mb-6">
            <div class="flex flex-col md:flex-row justify-between items-center">
                <div>
                    <h1 class="text-2xl font-bold text-gray-800">Shroombox Dashboard</h1>
                    <p class="text-gray-600">Current phase: <span x-text="currentPhase" class="font-medium"></span></p>
                </div>
                
                <!-- Sensor Status Alert - Warning (when not working) -->
                <div id="sensor-status-container"
                     x-show="measurements.sensor_status && !measurements.sensor_status.available" 
                     class="mt-4 md:mt-0 p-2 bg-yellow-100 border border-yellow-400 text-yellow-700 rounded flex items-center">
                    <svg class="w-5 h-5 mr-2" fill="currentColor" viewBox="0 0 20 20">
                        <path fill-rule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clip-rule="evenodd"></path>
                    </svg>
                    <span id="sensor-status-message" x-text="measurements.sensor_status ? measurements.sensor_status.message : ''"></span>
                </div>
                
                <!-- Sensor Status Alert - Success (when working) -->
                <div id="sensor-status-success"
                     x-show="measurements.sensor_status && measurements.sensor_status.available" 
                     class="mt-4 md:mt-0 p-2 bg-green-100 border border-green-400 text-green-700 rounded flex items-center">
                    <svg class="w-5 h-5 mr-2" fill="currentColor" viewBox="0 0 20 20">
                        <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"></path>
                    </svg>
                    <span id="sensor-status-success-message" x-text="measurements.sensor_status && measurements.sensor_status.available ? 'Sensor connected and working properly' : ''"></span>
                </div>
                
                <div class="mt-4 md:mt-0">
                    <button @click="refreshData" class="bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded shadow">
                        <span x-show="!isRefreshing">Refresh</span>
                        <span x-show="isRefreshing">Refreshing...</span>
                    </button>
                </div>
            </div>
        </div>

        <!-- Environment Controls -->
        <div class="bg-white rounded-lg shadow-sm p-6">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-xl font-semibold text-gray-800">Environment Controls</h2>
                <div class="flex items-center">
                    <label class="block text-sm font-medium text-gray-700 mr-2">Growth Phase:</label>
                    <select 
                        id="phase-select"
                        x-model="currentPhase" 
                        @change="updatePhase"
                        class="rounded-md border-gray-300 shadow-sm focus:border-green-500 focus:ring-green-500"
                    >
                        <option value="colonisation">Colonisation</option>
                        <option value="growing">Growing</option>
                        <option value="cake">Cake</option>
                    </select>
                </div>
            </div>
            <div class="grid grid-cols-3 gap-6">
                <!-- Temperature Column -->
                <div>
                    <div class="mb-4">
                        <label class="block text-sm font-medium text-gray-700 mb-1">Temperature</label>
                        <div class="text-2xl font-medium temperature-value" x-text="measurements.temperature + ' °C'"></div>
                        <div class="text-xs text-gray-500 flex items-center" x-show="measurements.source">
                            <span x-show="measurements.source === 'sensor'" class="flex items-center measurement-source">
                                <svg class="w-3 h-3 text-green-500 mr-1" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
                                    <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"></path>
                                </svg>
                                Live
                            </span>
                            <span x-show="measurements.source === 'cache'" class="flex items-center measurement-source">
                                <svg class="w-3 h-3 text-yellow-500 mr-1" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
                                    <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm1-12a1 1 0 10-2 0v4a1 1 0 00.293.707l2.828 2.829a1 1 0 101.415-1.415L11 9.586V6z" clip-rule="evenodd"></path>
                                </svg>
                                Cached
                            </span>
                            <span x-show="measurements.source === 'influxdb'" class="flex items-center measurement-source">
                                <svg class="w-3 h-3 text-blue-500 mr-1" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
                                    <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm1-11a1 1 0 10-2 0v2H7a1 1 0 100 2h2v2a1 1 0 102 0v-2h2a1 1 0 100-2h-2V7z" clip-rule="evenodd"></path>
                                </svg>
                                Database
                            </span>
                        </div>
                    </div>
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-2">Setpoint (°C)</label>
                        <input 
                            id="temperature-setpoint"
                            type="number" 
                            class="block w-24 rounded-md border border-gray-300 shadow-sm focus:border-green-500 focus:ring-green-500 p-2"
                            step="0.1"
                            min="0"
                            max="40"
                            :value="setpoints.temperature"
                            @input="setpoints.temperature = parseFloat($el.value)"
                            @change="updateSetpoint('temperature')"
                        >
                    </div>
                </div>

                <!-- Humidity Column -->
                <div>
                    <div class="mb-4">
                        <label class="block text-sm font-medium text-gray-700 mb-1">Humidity</label>
                        <div class="text-2xl font-medium humidity-value" x-text="measurements.humidity + ' %'"></div>
                        <div class="text-xs text-gray-500 flex items-center" x-show="measurements.source">
                            <span x-show="measurements.source === 'sensor'" class="flex items-center measurement-source">
                                <svg class="w-3 h-3 text-green-500 mr-1" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
                                    <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"></path>
                                </svg>
                                Live
                            </span>
                            <span x-show="measurements.source === 'cache'" class="flex items-center measurement-source">
                                <svg class="w-3 h-3 text-yellow-500 mr-1" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
                                    <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm1-12a1 1 0 10-2 0v4a1 1 0 00.293.707l2.828 2.829a1 1 0 101.415-1.415L11 9.586V6z" clip-rule="evenodd"></path>
                                </svg>
                                Cached
                            </span>
                            <span x-show="measurements.source === 'influxdb'" class="flex items-center measurement-source">
                                <svg class="w-3 h-3 text-blue-500 mr-1" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
                                    <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm1-11a1 1 0 10-2 0v2H7a1 1 0 100 2h2v2a1 1 0 102 0v-2h2a1 1 0 100-2h-2V7z" clip-rule="evenodd"></path>
                                </svg>
                                Database
                            </span>
                        </div>
                    </div>
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-2">Setpoint (%)</label>
                        <input 
                            id="humidity-setpoint"
                            type="number" 
                            class="block w-24 rounded-md border border-gray-300 shadow-sm focus:border-green-500 focus:ring-green-500 p-2"
                            step="1"
                            min="0"
                            max="100"
                            :value="setpoints.humidity"
                            @input="setpoints.humidity = parseFloat($el.value)"
                            @change="updateSetpoint('humidity')"
                        >
                    </div>
                </div>

                <!-- CO2 Column -->
                <div>
                    <div class="mb-4">
                        <label class="block text-sm font-medium text-gray-700 mb-1">CO2</label>
                        <div class="text-2xl font-medium co2-value" x-text="measurements.co2 + ' ppm'"></div>
                        <div class="text-sm font-medium text-gray-600 fan-speed-display" x-text="'Fan: ' + (measurements.fan_speed !== undefined ? parseFloat(measurements.fan_speed).toFixed(1) : '--') + '%'"></div>
                        <div class="text-xs text-gray-500 flex items-center" x-show="measurements.source">
                            <span x-show="measurements.source === 'sensor'" class="flex items-center measurement-source">
                                <svg class="w-3 h-3 text-green-500 mr-1" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
                                    <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"></path>
                                </svg>
                                Live
                            </span>
                            <span x-show="measurements.source === 'cache'" class="flex items-center measurement-source">
                                <svg class="w-3 h-3 text-yellow-500 mr-1" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
                                    <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm1-12a1 1 0 10-2 0v4a1 1 0 00.293.707l2.828 2.829a1 1 0 101.415-1.415L11 9.586V6z" clip-rule="evenodd"></path>
                                </svg>
                                Cached
                            </span>
                            <span x-show="measurements.source === 'influxdb'" class="flex items-center measurement-source">
                                <svg class="w-3 h-3 text-blue-500 mr-1" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
                                    <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm1-11a1 1 0 10-2 0v2H7a1 1 0 100 2h2v2a1 1 0 102 0v-2h2a1 1 0 100-2h-2V7z" clip-rule="evenodd"></path>
                                </svg>
                                Database
                            </span>
                        </div>
                    </div>
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-2">Setpoint (ppm)</label>
                        <input 
                            id="co2-setpoint"
                            type="number" 
                            class="block w-24 rounded-md border border-gray-300 shadow-sm focus:border-green-500 focus:ring-green-500 p-2"
                            step="100"
                            min="400"
                            max="10000"
                            :value="setpoints.co2"
                            @input="setpoints.co2 = Math.min(10000, Math.max(400, parseInt($el.value) || 400))"
                            @change="updateSetpoint('co2')"
                        >
                        <p class="text-xs text-gray-500 mt-1">Range: 400-10,000 ppm</p>
                    </div>
                    
                    <!-- Manual Fan Control -->
                    <div class="mt-4 border-t pt-4">
                        <div class="flex items-center mb-2">
                            <label class="block text-sm font-medium text-gray-700 mr-2">Manual Fan Control:</label>
                            <div class="relative inline-block w-10 mr-2 align-middle select-none">
                                <input 
                                    type="checkbox" 
                                    id="manual-fan-toggle" 
                                    x-model="fanControl.manualMode"
                                    @change="toggleManualFanControl"
                                    class="toggle-checkbox absolute block w-6 h-6 rounded-full bg-white border-4 appearance-none cursor-pointer"
                                />
                                <label 
                                    for="manual-fan-toggle" 
                                    class="toggle-label block overflow-hidden h-6 rounded-full bg-gray-300 cursor-pointer"
                                ></label>
                            </div>
                            <span class="text-sm text-gray-600" x-text="fanControl.manualMode ? 'Enabled' : 'Disabled'"></span>
                        </div>
                        
                        <div x-show="fanControl.manualMode" class="space-y-2">
                            <label class="block text-sm font-medium text-gray-700">Fan Speed (%)</label>
                            <div class="flex items-center space-x-2">
                                <input 
                                    type="range" 
                                    min="0" 
                                    max="100" 
                                    step="1" 
                                    x-model="fanControl.speed"
                                    @change="updateManualFanSpeed"
                                    class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"
                                />
                                <span class="text-sm font-medium w-10 text-right" x-text="fanControl.speed + '%'"></span>
                            </div>
                            <div id="fan-speed-feedback" class="mt-2 text-sm"></div>
                        </div>
                    </div>
                </div>

                <!-- Fan PID Parameters Column -->
                <div>
                    <div class="mb-4">
                        <label class="block text-sm font-medium text-gray-700 mb-1">Fan PID Parameters</label>
                        <div class="text-xs text-gray-500 mb-2">
                            (Negative value: higher CO2 → higher fan speed)
                        </div>
                    </div>
                    <div class="flex items-center space-x-3">
                        <div class="flex items-center">
                            <label class="w-8 text-sm font-medium text-gray-700 mr-2">Kp:</label>
                            <input 
                                id="kp-setting"
                                type="number" 
                                class="block w-20 rounded-md border border-gray-300 shadow-sm focus:border-green-500 focus:ring-green-500 p-2"
                                step="0.1"
                                min="-10"
                                max="0"
                                :value="pidSettings.kp"
                                @input="pidSettings.kp = parseFloat($el.value)"
                                @change="updatePidSetting('kp')"
                            >
                        </div>
                        <div class="flex items-center">
                            <label class="w-8 text-sm font-medium text-gray-700 mr-2">Ki:</label>
                            <input 
                                id="ki-setting"
                                type="number" 
                                class="block w-20 rounded-md border border-gray-300 shadow-sm focus:border-green-500 focus:ring-green-500 p-2"
                                step="0.01"
                                min="-1"
                                max="0"
                                :value="pidSettings.ki"
                                @input="pidSettings.ki = parseFloat($el.value)"
                                @change="updatePidSetting('ki')"
                            >
                        </div>
                        <div class="flex items-center">
                            <label class="w-8 text-sm font-medium text-gray-700 mr-2">Kd:</label>
                            <input 
                                id="kd-setting"
                                type="number" 
                                class="block w-20 rounded-md border border-gray-300 shadow-sm focus:border-green-500 focus:ring-green-500 p-2"
                                step="0.01"
                                min="-1"
                                max="1"
                                :value="pidSettings.kd"
                                @input="pidSettings.kd = parseFloat($el.value)"
                                @change="updatePidSetting('kd')"
                            >
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Device Settings -->
        <div class="bg-white rounded-lg shadow-sm p-6">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-xl font-semibold text-gray-800">Device Settings</h2>
                <div class="flex items-center space-x-2">
                    <div x-show="lastDeviceUpdate" class="text-xs text-gray-500 animate-pulse">
                        Last updated: <span x-text="lastDeviceUpdate"></span>
                    </div>
                    <button 
                        @click="rescanDevices"
                        class="inline-flex items-center px-3 py-2 border border-transparent text-sm leading-4 font-medium rounded-md text-white bg-green-600 hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500"
                        :class="{'opacity-50 cursor-not-allowed': isScanning}"
                        :disabled="isScanning"
                    >
                        <!-- Spinner for loading state -->
                        <svg x-show="isScanning" class="animate-spin -ml-1 mr-2 h-4 w-4 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                            <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                            <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                        </svg>
                        <span x-text="isScanning ? 'Scanning...' : 'Scan for Devices'"></span>
                    </button>
                </div>
            </div>
            <div class="grid grid-cols-2 gap-6">
                <!-- Heater Section -->
                <div class="space-y-4">
                    <h3 class="text-lg font-medium text-gray-700">Heater</h3>
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-1">Select Device</label>
                        <select 
                            x-model="selectedHeater"
                            @change="updateDeviceRole('heater')"
                            class="block w-full rounded-md border-gray-300 shadow-sm focus:border-green-500 focus:ring-green-500 mb-2"
                        >
                            <option value="">Select a device...</option>
                            <template x-for="device in availableDevices" :key="device.ip">
                                <option 
                                    :value="device.ip"
                                    x-text="device.name || device.ip"
                                ></option>
                            </template>
                        </select>
                        <!-- Heater Device Info -->
                        <div x-show="selectedHeater" class="mt-2 text-sm space-y-1 text-gray-600 bg-gray-50 p-3 rounded-md" :data-device="'heater'">
                            <template x-for="device in availableDevices" :key="device.ip">
                                <div x-show="device.ip === selectedHeater">
                                    <div><span class="font-medium">IP:</span> <span x-text="device.ip"></span></div>
                                    <div><span class="font-medium">MAC:</span> <span x-text="device.mac"></span></div>
                                    <div><span class="font-medium">Model:</span> <span x-text="device.model"></span></div>
                                    <div><span class="font-medium">Type:</span> <span x-text="device.type"></span></div>
                                    <div class="space-y-1">
                                        <div class="flex items-center">
                                            <span class="text-sm text-gray-600 mr-2">Status:</span>
                                            <span 
                                                class="device-status px-2 py-1 text-xs font-medium rounded-full"
                                                :class="device.state ? 'on bg-green-100 text-green-800' : 'off bg-gray-100 text-gray-800'"
                                                x-text="device.state ? 'ON' : 'OFF'"
                                            ></span>
                                            <button 
                                                @click="toggleDevice('heater')"
                                                class="toggle-button ml-2 px-2 py-1 text-xs font-medium rounded text-white hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-500"
                                                :class="device.state ? 'on bg-blue-500' : 'off bg-blue-500'"
                                                x-text="device.state ? 'Turn OFF' : 'Turn ON'"
                                                :data-ip="device.ip"
                                            ></button>
                                        </div>
                                    </div>
                                </div>
                            </template>
                        </div>
                    </div>
                </div>

                <!-- Humidifier Section -->
                <div class="space-y-4">
                    <h3 class="text-lg font-medium text-gray-700">Humidifier</h3>
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-1">Select Device</label>
                        <select 
                            x-model="selectedHumidifier"
                            @change="updateDeviceRole('humidifier')"
                            class="block w-full rounded-md border-gray-300 shadow-sm focus:border-green-500 focus:ring-green-500 mb-2"
                        >
                            <option value="">Select a device...</option>
                            <template x-for="device in availableDevices" :key="device.ip">
                                <option 
                                    :value="device.ip"
                                    x-text="device.name || device.ip"
                                ></option>
                            </template>
                        </select>
                        <!-- Humidifier Device Info -->
                        <div x-show="selectedHumidifier" class="mt-2 text-sm space-y-1 text-gray-600 bg-gray-50 p-3 rounded-md" :data-device="'humidifier'">
                            <template x-for="device in availableDevices" :key="device.ip">
                                <div x-show="device.ip === selectedHumidifier">
                                    <div><span class="font-medium">IP:</span> <span x-text="device.ip"></span></div>
                                    <div><span class="font-medium">MAC:</span> <span x-text="device.mac"></span></div>
                                    <div><span class="font-medium">Model:</span> <span x-text="device.model"></span></div>
                                    <div><span class="font-medium">Type:</span> <span x-text="device.type"></span></div>
                                    <div class="space-y-1">
                                        <div class="flex items-center">
                                            <span class="text-sm text-gray-600 mr-2">Status:</span>
                                            <span 
                                                class="device-status px-2 py-1 text-xs font-medium rounded-full"
                                                :class="device.state ? 'on bg-green-100 text-green-800' : 'off bg-gray-100 text-gray-800'"
                                                x-text="device.state ? 'ON' : 'OFF'"
                                            ></span>
                                            <button 
                                                @click="toggleDevice('humidifier')"
                                                class="toggle-button ml-2 px-2 py-1 text-xs font-medium rounded text-white hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-500"
                                                :class="device.state ? 'on bg-blue-500' : 'off bg-blue-500'"
                                                x-text="device.state ? 'Turn OFF' : 'Turn ON'"
                                                :data-ip="device.ip"
                                            ></button>
                                        </div>
                                    </div>
                                </div>
                            </template>
                        </div>
                    </div>
                </div>
            </div>
        </div>

    </div>

    <!-- Debug Panel -->
    <div id="debug-panel" class="bg-black bg-opacity-80 text-white p-4 mt-6 rounded-lg z-[9000] max-h-64 overflow-auto text-xs font-mono mx-auto max-w-6xl">
        <h3 class="text-sm font-bold mb-2">Debug Panel</h3>
        <div id="debug-log"></div>
    </div>

    <script>
        // Add debug logging function
